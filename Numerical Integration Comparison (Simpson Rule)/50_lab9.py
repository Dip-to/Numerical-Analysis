# -*- coding: utf-8 -*-
"""50_lab9

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QOTCTxr017q_t8Gt_k9YzkAkbhK-n1Na
"""

from prettytable import PrettyTable
import matplotlib.pyplot as plt

def right_riemann_sum(func, a, b, n):
    sum_result = 0
    delta_x = (b - a) / n
    i = 1
    while i <= n:
      p=0
      x_i = a + i * delta_x
      sum_result += func(x_i)
      p=0
      i += 1
    return sum_result * delta_x
def trapezoidal_rule(func, a, b, n):
    i = 1
    sum_result = 0.5 * (func(a) + func(b))
    ana=sum_result
    xy=sum_result
    #  x_i = a + i * delta_x
    #   sum_result += func(x_i)
    #   p=0
    p=0
    delta_x = (b - a) / n

    while i < n:
      x_i = a + i * delta_x
      p=0

      sum_result += func(x_i)
      i += 1
      p=0
    return sum_result * delta_x

def midpoint_rule(func, a, b, n):
    i = 0

    delta_x = (b - a) / n
    sum_result = 0
    ana=sum_result
    xy=sum_result
    while i < n:
      p=0
      x_mid = a + (i + 0.5) * delta_x
      p=0
      sum_result += func(x_mid)
      i += 1
    return sum_result * delta_x
def integrated_f_fx(x):
    return x**3/3
def left_riemann_sum(func, a, b, n):
    i = 0
    delta_x = (b - a) / n
    sum_result = 0
    p=0
    while i < n:
      x_i = a + i * delta_x
      p=0
      sum_result += func(x_i)
      i += 1
    return sum_result * delta_x


def fun_f(x):
    return x**2

def simpson_rule(func, a, b, n):

    if n % 2 != 0:
        raise ValueError("n must be even")

    x_values = []
    p=0
    delta_x = (b - a) / n
    x_values.clear()
    for i in range(0, n+1):
        x_values.append(a + i * delta_x)
        p=0

    sum_result = func(a) + func(b)
    ans=sum_result

    p=0
    for i in range(1, n):
        if i % 2 == 0:
            p=0
            xyz=sum_result
            # print(xyz)
            sum_result += 2 * func(x_values[i])
            ans=sum_result

        else:
            xyz=sum_result
            # print(xyz)
            p=0
            sum_result += 4 * func(x_values[i])
            ans=sum_result


    return ans




n_values = []
simpson = []
a = 0
n = 2
b = 4
leftreimansum = []
midpoint = []
true_value = integrated_f_fx(b) - integrated_f_fx(a)
trapezoid = []
actual=[]
rightreimansum =[]





me = PrettyTable(["n" ,"Left Hand Reimann Sum", "Midpoint Rule",  "Right Hand Reimann Sum", "Simpson Rule","Trapezoidal Rule", "Actual Value"])

while n<10000:



  result_trapezoidal = trapezoidal_rule(fun_f, a, b,n)
  trapezoid.append(result_trapezoidal)
  result_simpson = simpson_rule(fun_f, a, b,n)

  simpson.append(result_simpson)

  result_right = right_riemann_sum(fun_f, a, b,n)
  rightreimansum.append(result_right)

  result_left = left_riemann_sum(fun_f, a, b, n)
  leftreimansum.append(result_left)

  result_midpoint = midpoint_rule(fun_f, a, b, n)

  midpoint.append(result_midpoint)
  me.add_row([n, result_left, result_midpoint,result_right,result_simpson,result_trapezoidal,true_value])
  n+=2

  n_values.append(n)
  actual.append(true_value)


print(me)

plt.xlabel("n")
plt.ylabel("approx values")
plt.plot(n_values, rightreimansum, color='blue', label='Right Reimann')
plt.title("Approximation vs n")
plt.plot(n_values, midpoint, color='red', label='Midpoint')
plt.plot(n_values, simpson, color='black', label='Simpson')
plt.legend()
plt.plot(n_values, leftreimansum, color='yellow', label='Left Reimann')
plt.plot(n_values, actual, color='orange', label='Actual Value')
plt.grid(True)
plt.plot(n_values, trapezoid, color='green', label='Trapezoid')
plt.show()