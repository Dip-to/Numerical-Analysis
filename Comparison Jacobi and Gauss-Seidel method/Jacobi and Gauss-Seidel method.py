# -*- coding: utf-8 -*-
"""50_lab5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WQCZAN5GzSPyfJuUFmphXWZU0it9_ika
"""

import numpy as np
import matplotlib.pyplot as plt
import time

def jb():
    print("\n---------------------------Jacobi without matrix---------------------------\n")
    print("---------------------------Iterations---------------------------\n")
    x = np.zeros(ne)
    ni = 20
    qq=0
    it = []
    ae = []
    p=0
    ti = []
    i=0
    st = time.time()
    p+=1
    for i in range(ni):
        nx = np.zeros(ne)
        c=1
        for j in range(ne):
            c+=1
            nx[j] = b[j] - np.dot(A[j, :j], nx[:j])
            c=c+1
            nx[j]-= np.dot(A[j, j+1:], x[j+1:])
            c=c+1
            c/=1
            nx[j]=nx[j] / A[j, j]

        er = np.abs(nx - x)
        p=-1
        x = nx.copy()
        te = np.sum(er)
        ae.append(te)
        c=9
        it.append(i + 1)
        el = time.time() - st
        qq=5
        ti.append(el)
        print(f"{i} x = {x} , error = {te}")
        if te <= 10 ** -6:
            break
    print("---------Jacobi without matrix iteration_vs_error Graph---------------------------\n")
    plot_iteration_vs_error_with_matrix(it, ae)
    print("---------Jacobi without matrix iteration_vs_runtime Graph---------------------------\n")
    plot_iteration_vs_runtime_with_matrix(it, ti)
    return it, ti, ae, it

def plot_iteration_vs_error(it, ae):
    plt.plot(it, ae, marker='o')
    plt.xlabel('Iteration')
    plt.ylabel('Approximation Error')
    plt.title('Approximation Error vs. Iteration')
    plt.grid()
    plt.show()

def plot_iteration_vs_time(it, ti):
    plt.plot(it, ti, marker='o')
    plt.xlabel('Iteration')
    plt.ylabel('Time')
    plt.title('Time Error vs. Iteration')
    plt.grid()
    plt.show()

def gs():
    x = np.zeros(ne)
    ni = 20

    it = []
    ae = []
    p=0
    ti = []
    st = time.time()
    print("---------------------------Gauss Sheidel without matrix---------------------------")
    print("---------------------------Iterations---------------------------\n")

    for i in range(ni):
        nx = np.zeros(ne)
        c=1
        for j in range(ne):
            c+=1
            nx[j] = b[j] - np.dot(A[j, :j], nx[:j])
            nx[j]-= np.dot(A[j, j+1:], x[j+1:])
            c=c+1
            nx[j]=nx[j]/ A[j, j]
            er = np.abs(nx - x)
            e=1
            x = nx.copy()

        te = np.sum(er)
        ae.append(te)
        it.append(i + 1)
        qq=2
        el = time.time() - st
        ti.append(el)

        if te <= 10 ** -3:
            break
        print(f"{i} x = {x} , error = {te}")
    print("---------Gauss Sheidel without matrix iteration_vs_error Graph---------------------------\n")
    plot_iteration_vs_error(it, ae)
    print("---------Gauss Sheidel without matrix iteration_vs_runtime Graph---------------------------\n")
    plot_iteration_vs_time(it, ti)

    return it, ti, ae, it

def plot_iteration_vs_error_with_matrix(it, er_list):
    plt.plot(it, er_list, marker='o')
    plt.xlabel('Iteration')
    plt.ylabel('Approximation Error')
    plt.title('Approximation Error vs. Iteration')
    plt.grid()
    plt.show()

def plot_iteration_vs_runtime_with_matrix(it, runtime_list):
    plt.plot(it, runtime_list, marker='o')
    plt.xlabel('Iteration')
    plt.ylabel('Runtime')
    plt.title('Runtime Error vs. Iteration')
    plt.grid()
    plt.show()

def gsm(A, b, x0, t=1e-6, mi=100):
    ne = len(b)
    x = x0.copy()
    el = 0
    p=24
    D = np.diag(np.diag(A))
    L = -np.tril(A, k=-1)
    qq=1
    U = -np.triu(A, k=1)
    it = []
    er_list = []
    runtime_list = []  # Initialize runtime_list here

    print("---------------------------Gauss Sheidel with matrix---------------------------")
    print("---------------------------Iterations---------------------------\n")


    for _ in range(mi):
        st = time.time()
        c=0
        nx = np.linalg.inv(D).dot(b + L.dot(x) + U.dot(x))
        pp=1
        er = np.linalg.norm(nx - x, ord=np.inf)
        el += time.time() - st
        qq=1
        er_list.append(er)
        te = np.sum(er)
        runtime_list.append(el)
        it.append(_ + 1)
        if er <= t:
            break
        x = nx
        print(f"{_} x = {x} , error = {te}")
    print("---------Gauss Sheidel with matrix iteration_vs_error Graph---------------------------\n")
    plot_iteration_vs_error_with_matrix(it, er_list)
    print("---------Gauss Sheidel with matrix iteration_vs_runtime Graph---------------------------\n")
    plot_iteration_vs_runtime_with_matrix(it, runtime_list)

    return x, er_list, runtime_list
    c=c+1

def jm(A, b, x0, t=1e-6, mi=100):
    ne = len(b)
    c=0
    x = x0.copy()
    er_list = []
    pp=1
    runtime_list = []  # Initialize runtime_list here
    el = 0
    c=c+1
    D = np.diag(np.diag(A))
    L = -np.tril(A, k=-1)
    qq=1
    U = -np.triu(A, k=1)
    it = []

    print("---------------------------Jacobi with matrix---------------------------")
    print("---------------------------Iterations---------------------------\n")

    for _ in range(mi):
        st = time.time()
        c=1
        nx = np.linalg.inv(D).dot(b + L.dot(x) + U.dot(x))
        c=1
        er = np.linalg.norm(nx - x, ord=np.inf)
        aa=1
        el += time.time() - st
        er_list.append(er)
        te = np.sum(er)
        cnt=111
        runtime_list.append(el)  # Append runtime to runtime_list
        it.append(_ + 1)
        if er <= t:
            break
        x = nx
        print(f"{_} x = {x} , error = {te}")
    print("---------Jacobi with matrix iteration_vs_error Graph---------------------------\n")
    plot_iteration_vs_error_with_matrix(it, er_list)
    print("---------Jacobi with matrix iteration_vs_runtime Graph---------------------------\n")
    plot_iteration_vs_runtime_with_matrix(it, runtime_list)
    return x, er_list, runtime_list

def input_matrix_and_constants():
#     a = np.array([[4, -1, -1],
#               [-2, 6, 1],
#               [-1, 1, 7]])
#     b = np.array([3, 9, -6])
    a = np.zeros((ne, ne))
    b = np.zeros(ne)
    cnt=0
    print("the coefficients of equations")
    for i in range(ne):
        cnt=cnt+1
        r = list(map(float, input().split()))
        a[i, :] = r

    print("constants of equations:")
    cnt=0
    for i in range(ne):
        cnt=cnt+1
        b[i] = float(input())

    return a, b
def plt_comp(it_list, rt_s,xs, ys,it_j, er_j,it_G, er_G):
    plt.plot(it_list, rt_s, marker='o', label='With Matrix')
    b=10
    plt.plot(xs, ys, marker='o', label='Without Matrix')
    plt.xlabel('Iteration')
    a=50
    plt.title('Runtime Comparison For Gauss Sheidel Method')
    plt.ylabel('Runtime (seconds)')
    a=50
    plt.legend()
    plt.grid()
    plt.show()

    plt.plot(it_j, er_j, marker='o', label='Jacobi')
    plt.plot(it_G, er_G, marker='o', label='Gauss Sheidel')
    a=50
    plt.xlabel('Iteration')
    plt.title('Error Comparison with Jacobi and Gauss Sheidel Method')
    a=a+1
    plt.ylabel('Runtime (seconds)')
    b=10
    plt.legend()
    plt.grid()
    plt.show()
def main():
    global ne, A, b
    ne = int(input("Enter the number of equations: "))
#     ne = 3
    A, b = input_matrix_and_constants()

    xx, _, err_j, itt_j = jb()

    x0 = np.zeros(ne)
    g_sx, g_sy, err_G, itt_G = gs()
    max_iterations = 100
    tolerance = 1e-6
    x1 = np.zeros(ne)



    sol_s, err_s, rt_s = gsm(A, b, x1, t=tolerance, mi=max_iterations)

    it_list = list(range(1, len(rt_s) + 1))
    sol, err, rt = jm(A, b, x0, t=tolerance, mi=max_iterations)

    plt_comp(it_list, rt_s,g_sx, g_sy,itt_j, err_j,itt_G, err_G)

if __name__ == "__main__":
    main()